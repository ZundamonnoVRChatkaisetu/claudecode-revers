import { generateCompleteEncodingScript, generateFunctionEncodingLoop } from './shell-function-encoder.js';
import { generateCompleteOptionsScript, generateSafeShellOptions } from './shell-options-manager.js';
import { 
  initializeSnapshotFile, 
  createSnapshotHeader, 
  createAliasUnsetSection,
  generateTempSnapshotPath,
  createSnapshotFile,
  SNAPSHOT_SECTIONS 
} from './snapshot-file-manager.js';
import { quote as shellQuote } from 'shell-quote';

/**
 * シェルスナップショット生成の統合クラス
 */
export class ShellSnapshotGenerator {
  constructor(options = {}) {
    this.shellType = options.shellType || 'bash';
    this.maxFunctions = options.maxFunctions || 1000;
    this.maxAliases = options.maxAliases || 1000;
    this.maxOptions = options.maxOptions || 1000;
    this.tempDir = options.tempDir || require('os').tmpdir();
    this.metadata = {
      version: '1.0.0',
      generator: 'claude-cli',
      timestamp: new Date().toISOString(),
      shellType: this.shellType,
      ...options.metadata
    };
  }

  /**
   * 完全なシェルスナップショット作成スクリプトを生成
   */
  generateCompleteSnapshotScript(snapshotFilePath, sourceFile = null) {
    const quotedSnapshotPath = shellQuote([snapshotFilePath]);
    const quoteChar = '"';
    
    return `
#!/bin/bash
# Shell Snapshot Generation Script
# Generated by Claude CLI

SNAPSHOT_FILE=${quotedSnapshotPath}
${sourceFile ? `source "${sourceFile}" < /dev/null` : ''}

# First, create/clear the snapshot file
echo "# Snapshot file" >| $SNAPSHOT_FILE

# When this file is sourced, we first unalias to avoid conflicts
# This is necessary because aliases get "frozen" inside function definitions at definition time,
# which can cause unexpected behavior when functions use commands that conflict with aliases
echo "# Unset all aliases to avoid conflicts with functions" >> $SNAPSHOT_FILE
echo "unalias -a 2>/dev/null || true" >> $SNAPSHOT_FILE

# Function to get env in posix format
env_to_posix() {
  env | head -n 1000 | while IFS= read -r line; do
    case "$line" in
      *=*)
        key="\${line%%=*}"
        value="\${line#*=}"
        
        # Skip problematic variables
        case "$key" in
          _|SHLVL|OLDPWD|PWD|RANDOM|SECONDS|LINENO|PPID|BASHPID|HISTCMD|SHELL_SESSION_ID|SHELL_SESSION_DID_INIT|SHELL_SESSION_DID_HISTORY_CHECK|ZSH_EXECUTION_STRING|ZSH_EVAL_CONTEXT)
            continue
            ;;
        esac
        
        # Skip Bash and Zsh function definitions
        case "$value" in
          "() {"*|*$'\\n}'*|*$'\\n'*"}"*)
            continue
            ;;
        esac
        
        # Escape special characters
        escaped_value=$(printf '%s' "$value" | sed 's/[\\\\$"]/\\\\&/g')
        printf 'export %s="%s"\\n' "$key" "$escaped_value"
        ;;
    esac
  done
}

# Set shell options
echo "# Shell options" >> $SNAPSHOT_FILE
echo "set +o posix 2>/dev/null || true" >> $SNAPSHOT_FILE
echo "set +o restricted 2>/dev/null || true" >> $SNAPSHOT_FILE
echo "set -o nolog 2>/dev/null || true" >> $SNAPSHOT_FILE
echo "set +o nounset 2>/dev/null || true" >> $SNAPSHOT_FILE
echo "set -o pipefail 2>/dev/null || true" >> $SNAPSHOT_FILE
echo "" >> $SNAPSHOT_FILE

# Add env vars
echo "# Environment variables" >> $SNAPSHOT_FILE
env_to_posix >> $SNAPSHOT_FILE
echo "" >> $SNAPSHOT_FILE

# Clear aliases and functions
echo "# Clear aliases and functions" >> $SNAPSHOT_FILE
echo "unset -f \\$(declare -F | cut -d' ' -f3) 2>/dev/null || true" >> $SNAPSHOT_FILE
echo "unalias -a 2>/dev/null || true" >> $SNAPSHOT_FILE

# Process shell functions
echo "# Shell functions" >> $SNAPSHOT_FILE
for func in $(declare -F | cut -d' ' -f3); do
  if ! declare -F "$func" >/dev/null 2>&1; then
    continue
  fi
  
  # Encode the function to base64, preserving all special characters
  encoded_func=$(declare -f "$func" | base64)
  
  # Write the function definition to the snapshot
  echo "eval ${quoteChar}${quoteChar}$(echo '$encoded_func' | base64 -d)${quoteChar}${quoteChar} > /dev/null 2>&1" >> $SNAPSHOT_FILE
done

echo "" >> $SNAPSHOT_FILE
echo "# Aliases" >> $SNAPSHOT_FILE
alias | sed 's/^alias //g' | sed 's/^/alias -- /' | head -n ${this.maxAliases} >> $SNAPSHOT_FILE

# Check if rg is available, if not create an alias to bundled ripgrep
echo "# Check for rg availability" >> $SNAPSHOT_FILE
echo "if ! command -v rg >/dev/null 2>&1; then" >> $SNAPSHOT_FILE
echo "  alias rg='\${CLAUDE_RIPGREP_PATH:-rg}'" >> $SNAPSHOT_FILE
echo "fi" >> $SNAPSHOT_FILE

# Shell Options
echo "" >> $SNAPSHOT_FILE
echo "# Shell Options" >> $SNAPSHOT_FILE
shopt -p | head -n ${this.maxOptions} >> $SNAPSHOT_FILE
set -o | grep "on" | awk '{print "set -o " $1}' | head -n ${this.maxOptions} >> $SNAPSHOT_FILE
echo "shopt -s expand_aliases" >> $SNAPSHOT_FILE

# Add PATH to the file
echo "" >> $SNAPSHOT_FILE
echo "# PATH" >> $SNAPSHOT_FILE
echo "export PATH='$PATH'" >> $SNAPSHOT_FILE

echo "" >> $SNAPSHOT_FILE
echo "# Snapshot complete" >> $SNAPSHOT_FILE
echo "echo 'Shell snapshot loaded successfully' >&2" >> $SNAPSHOT_FILE
    `.trim();
  }

  /**
   * 非同期でスナップショット作成スクリプトを実行
   */
  async executeSnapshotCreation(snapshotFilePath, sourceFile = null) {
    const script = this.generateCompleteSnapshotScript(snapshotFilePath, sourceFile);
    
    return new Promise((resolve, reject) => {
      const { exec } = require('child_process');
      const shell = this.getShellPath();
      
      exec(shell, ['-c', script], {
        env: {
          ...(process.env.CLAUDE_CODE_DONT_INHERIT_ENV ? {} : process.env),
          SHELL: shell,
          GIT_EDITOR: 'true',
          CLAUDECODE: '1',
          CLAUDE_RIPGREP_PATH: this.getRipgrepPath()
        },
        timeout: 10000,
        maxBuffer: 1048576
      }, (error, stdout, stderr) => {
        if (error) {
          reject(new Error(`Failed to create shell snapshot: ${stderr}`));
        } else if (require('fs').existsSync(snapshotFilePath)) {
          const { statSync } = require('fs');
          const fileSize = statSync(snapshotFilePath).size;
          resolve({
            success: true,
            path: snapshotFilePath,
            size: fileSize,
            metadata: this.metadata
          });
        } else {
          reject(new Error('Snapshot file was not created'));
        }
      });
    });
  }

  /**
   * 一時的なスナップショットファイルを作成
   */
  async createTemporarySnapshot(sourceFile = null) {
    const tempPath = generateTempSnapshotPath();
    
    try {
      const result = await this.executeSnapshotCreation(tempPath, sourceFile);
      return result;
    } catch (error) {
      // クリーンアップ
      try {
        require('fs').unlinkSync(tempPath);
      } catch {}
      throw error;
    }
  }

  /**
   * シェルパスを取得
   */
  getShellPath() {
    // 適切なシェルを検出（shell-snapshot.jsから移動）
    const { detectShell } = require('./shell-snapshot.js');
    return detectShell();
  }

  /**
   * ripgrepパスを取得
   */
  getRipgrepPath() {
    // ripgrep-loader.jsから取得
    try {
      const { getRipgrepPath } = require('./ripgrep-loader.js');
      return getRipgrepPath();
    } catch {
      return 'rg';
    }
  }

  /**
   * スナップショットファイルをロード（テスト用）
   */
  async loadSnapshot(snapshotFilePath) {
    return new Promise((resolve, reject) => {
      const { exec } = require('child_process');
      const shell = this.getShellPath();
      
      const testScript = `
        source "${snapshotFilePath}"
        echo "Snapshot loaded successfully"
        echo "Functions: $(declare -F | wc -l)"
        echo "Aliases: $(alias | wc -l)"
      `;
      
      exec(shell, ['-c', testScript], {
        timeout: 5000
      }, (error, stdout, stderr) => {
        if (error) {
          reject(new Error(`Failed to load snapshot: ${stderr}`));
        } else {
          resolve({
            success: true,
            output: stdout,
            stderr: stderr
          });
        }
      });
    });
  }

  /**
   * スナップショットファイルの統計情報を取得
   */
  analyzeSnapshot(snapshotFilePath) {
    try {
      const { readFileSync } = require('fs');
      const content = readFileSync(snapshotFilePath, 'utf8');
      const lines = content.split('\n');
      
      const stats = {
        totalLines: lines.length,
        sections: {},
        functions: 0,
        aliases: 0,
        environmentVars: 0,
        shellOptions: 0
      };
      
      let currentSection = null;
      
      for (const line of lines) {
        // セクション検出
        if (line.startsWith('# ')) {
          const section = line.substring(2).toLowerCase();
          currentSection = section;
          stats.sections[section] = (stats.sections[section] || 0) + 1;
        }
        
        // 要素カウント
        if (line.startsWith('eval ')) stats.functions++;
        if (line.startsWith('alias ')) stats.aliases++;
        if (line.startsWith('export ')) stats.environmentVars++;
        if (line.startsWith('set ') || line.startsWith('shopt ')) stats.shellOptions++;
      }
      
      return stats;
    } catch (error) {
      throw new Error(`Failed to analyze snapshot: ${error.message}`);
    }
  }
}

/**
 * デフォルトのスナップショットジェネレーターインスタンスを作成
 */
export function createDefaultSnapshotGenerator(options = {}) {
  return new ShellSnapshotGenerator(options);
}

/**
 * 簡単なスナップショット作成関数
 */
export async function createShellSnapshot(outputPath = null, sourceFile = null, options = {}) {
  const generator = createDefaultSnapshotGenerator(options);
  
  if (outputPath) {
    return await generator.executeSnapshotCreation(outputPath, sourceFile);
  } else {
    return await generator.createTemporarySnapshot(sourceFile);
  }
}